// generated by insrcdata version 0.3.0
import Foundation

public struct Bench : Hashable {
        var cstruct : UnsafePointer<bench_t>
    
    init(cstruct: UnsafePointer<bench_t>){
        self.cstruct = cstruct
    }
    init(index:Int){
        cstruct = BENCH_TABLE_PTR()+index
    }
    var byte: UInt32 {  bench_byte(cstruct) }
    static func byteRange(start:UInt32, stop:UInt32) -> bench_iter_t {
        bench_byte_range(start, stop) 
    }
    var short: UInt32 {  bench_short(cstruct) }
    static func shortRange(start:UInt32, stop:UInt32) -> bench_iter_t {
        bench_short_range(start, stop) 
    }
    var int: UInt32 {  bench_int(cstruct) }
    static func intRange(start:UInt32, stop:UInt32) -> bench_iter_t {
        bench_int_range(start, stop) 
    }
    var str: String { String(cString:  bench_str(cstruct)) }
    static func strRange(start:String, stop:String) -> bench_iter_t {
        bench_str_range(start.cString(using:.utf8), stop.cString(using:.utf8)) 
    }

} // struct Bench

extension bench_iter_t : Sequence, IteratorProtocol {
        public typealias Element = Bench
        public mutating func next() -> Bench? {
            if let ptr = bench_next(&self) {
                return Bench(cstruct:ptr)
            }
            return nil
        }
}


