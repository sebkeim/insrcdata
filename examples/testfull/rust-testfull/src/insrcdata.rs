// generated by insrcdata version 0.1.0

#![allow(dead_code)]
#![allow(unused_variables)]
use std::ops::Deref;
#[derive(Clone, Copy)]
pub enum Persons {
    Marie = 0,
    Pierre = 1,
    Irene = 2,
    Frederic = 3,
}
impl Deref for Persons {
    type Target =  Person;
    fn deref(&self) -> &'static Person {
        &person::TABLE[*self as usize]
    }
}
pub struct Person {
    name_ : &'static str,
    spouse_ : u8,
    father_ : u8,
    mother_ : u8,
}
impl Person {
    pub fn name(&self) -> &'static str { self.name_ }
    pub fn spouse(&self) -> &'static Person {
        &person::TABLE[self.spouse_ as usize]
    }
    pub fn father(&self) -> Option<&'static Person> {
        let index = self.father_;
        if index==0 { None } else { Some(&person::TABLE[index as usize -1]) }
    }
    pub fn mother(&self) -> Option<&'static Person> {
        let index = self.mother_;
        if index==0 { None } else { Some(&person::TABLE[index as usize -1]) }
    }
}

mod person {

const fn r(name:&'static str, spouse:u8, father:u8, mother:u8, ) -> super::Person {
    super::Person{name_:name, spouse_:spouse, father_:father, mother_:mother, }
}

pub static TABLE : [ super::Person ; 4 ] = [
   {r("Marie Curie", 1, 0, 0, )},
   {r("Pierre Curie", 0, 0, 0, )},
   {r("Irène Joliot-Curie", 3, 2, 1, )},
   {r("Frédéric Joliot-Curie", 2, 0, 0, )},
];

} // mod person

pub struct Strencoding {
    text_ : &'static str,
}
impl Strencoding {
    pub fn text(&self) -> &'static str { self.text_ }

    pub fn text_range(start:& str, stop:& str) -> strencoding::IndexIter {
        let mut lo = 0;
        let mut hi = strencoding::TEXT_INDEX.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            if start > strencoding::TABLE[strencoding::TEXT_INDEX[mid] as usize].text_ {
                 lo = mid + 1;
            } else {
                 hi = mid;
            }
        }

        let begin = lo;
        hi = strencoding::TEXT_INDEX.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            if stop < strencoding::TABLE[strencoding::TEXT_INDEX[mid] as usize].text_ {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        strencoding::IndexIter {
            indexes: Box::new(strencoding::TEXT_INDEX[begin..lo].iter()),
        }
    }
    pub fn array() -> &'static [Strencoding; 6]  { &strencoding::TABLE }
}

mod strencoding {


use std::mem;

pub struct IndexIter {
    pub indexes : Box<dyn Iterator<Item=&'static u8>>,
}

impl Iterator for IndexIter {
    type Item = & 'static super::Strencoding;

    fn next(&mut self) -> Option<&'static super::Strencoding> {
        let idx = self.indexes.next();
        match idx {
            Some(v) => Some(&TABLE[*v as usize]),
            None => None,
        }
    }
}

pub fn index_of(fic:&super::Strencoding) -> usize {
    ((fic  as *const _ as usize) - (&TABLE[0]  as *const _ as usize)) / mem::size_of::<super::Strencoding>()
}

const fn r(text:&'static str, ) -> super::Strencoding {
    super::Strencoding{text_:text, }
}

pub static TABLE : [ super::Strencoding ; 6 ] = [
   {r("𝒾ň𝗌яčḓẚᵵᶏ : 𝔢ᶆḃ℮𝚍 ᶌ𝖔ừᵳ ⅆằƫⱥ", )},
   {r("hello", )},
   {r("κόσμε", )},
   {r("いろはにほへとちりぬるを", )},
   {r("éventuellement validé", )},
   {r("Да, но фальшивый экземпляр", )},
];
pub static TEXT_INDEX : [ u8 ; 6 ] = [
    1, 4, 2, 5, 3, 0, 
];

} // mod strencoding

pub use strencoding::IndexIter as StrencodingIter;
