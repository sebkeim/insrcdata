// generated by insrcdata version 0.3.0
import Foundation

public struct Person : Hashable {
        var cstruct : UnsafePointer<person_t>
    
    init(cstruct: UnsafePointer<person_t>){
        self.cstruct = cstruct
    }
    init(ref:persons_t){
        cstruct = person_from_persons(ref)
    }
    var persons: persons_t { person_persons(cstruct) }
    var name: String { String(cString:  person_name(cstruct)) }
    var woman: Bool {  person_woman(cstruct) }
    var score: Float64 {  person_score(cstruct) }
    static func scoreRange(start:Float64, stop:Float64) -> person_iter_t {
        person_score_range(start, stop) 
    }
    var spouse : Person { Person(cstruct:person_spouse(cstruct)) }
    var father : Person? {
        var p = UnsafePointer<person_t>?(nil)
        if person_father(cstruct, &p) { return Person(cstruct:p!) } else { return nil }
    }
    var mother : Person? {
        var p = UnsafePointer<person_t>?(nil)
        if person_mother(cstruct, &p) { return Person(cstruct:p!) } else { return nil }
    }
    var wdata:wikidata_iter_t { person_wdata(cstruct) }
    var congress:congress_iter_t { person_congress(cstruct) }

} // struct Person

extension person_iter_t : Sequence, IteratorProtocol {
        public typealias Element = Person
        public mutating func next() -> Person? {
            if let ptr = person_next(&self) {
                return Person(cstruct:ptr)
            }
            return nil
        }
}


public struct Strencoding : Hashable {
        var cstruct : UnsafePointer<strencoding_t>
    
    init(cstruct: UnsafePointer<strencoding_t>){
        self.cstruct = cstruct
    }
    init(index:Int){
        cstruct = STRENCODING_TABLE_PTR()+index
    }
    var text: String { String(cString:  strencoding_text(cstruct)) }
    static func textRange(start:String, stop:String) -> strencoding_iter_t {
        strencoding_text_range(start.cString(using:.utf8), stop.cString(using:.utf8)) 
    }

} // struct Strencoding

extension strencoding_iter_t : Sequence, IteratorProtocol {
        public typealias Element = Strencoding
        public mutating func next() -> Strencoding? {
            if let ptr = strencoding_next(&self) {
                return Strencoding(cstruct:ptr)
            }
            return nil
        }
}


public struct Lettercase : Hashable {
        var cstruct : UnsafePointer<lettercase_t>
    
    init(cstruct: UnsafePointer<lettercase_t>){
        self.cstruct = cstruct
    }
    init(ref:lettercases_t){
        cstruct = lettercase_from_lettercases(ref)
    }
    var lettercases: lettercases_t { lettercase_lettercases(cstruct) }
    var name: String { String(cString:  lettercase_name(cstruct)) }
    var transformer: Transformer_t {  lettercase_transformer(cstruct) }
    var point: Point_t {  lettercase_point(cstruct) }
    var wdata2:wikidata_iter_t { lettercase_wdata2(cstruct) }
    var congress:congress_iter_t { lettercase_congress(cstruct) }

} // struct Lettercase

extension lettercase_iter_t : Sequence, IteratorProtocol {
        public typealias Element = Lettercase
        public mutating func next() -> Lettercase? {
            if let ptr = lettercase_next(&self) {
                return Lettercase(cstruct:ptr)
            }
            return nil
        }
}


public struct Wikidata : Hashable {
        var cstruct : UnsafePointer<wikidata_t>
    
    init(cstruct: UnsafePointer<wikidata_t>){
        self.cstruct = cstruct
    }
    init(index:Int){
        cstruct = WIKIDATA_TABLE_PTR()+index
    }
    var qid: UInt32 {  wikidata_qid(cstruct) }
    var object : WikidataObject { 
       let w = wikidata_object(cstruct)
       switch w.type {
             case WIKIDATA_PERSON: return .Person(Person(cstruct:w.person))
             case WIKIDATA_LETTERCASE: return .Lettercase(Lettercase(cstruct:w.lettercase))
             default : fatalError( "insrcdata variant index overflow")
        }
    }

} // struct Wikidata

extension wikidata_iter_t : Sequence, IteratorProtocol {
        public typealias Element = Wikidata
        public mutating func next() -> Wikidata? {
            if let ptr = wikidata_next(&self) {
                return Wikidata(cstruct:ptr)
            }
            return nil
        }
}
enum  WikidataObject : Hashable {
   case Person(Person)
   case Lettercase(Lettercase)
}



public struct Congress : Hashable {
        var cstruct : UnsafePointer<congress_t>
    
    init(cstruct: UnsafePointer<congress_t>){
        self.cstruct = cstruct
    }
    init(index:Int){
        cstruct = CONGRESS_TABLE_PTR()+index
    }
    var lccn: String { String(cString:  congress_lccn(cstruct)) }
    var object : CongressObject { 
       let w = congress_object(cstruct)
       switch w.type {
             case CONGRESS_NONE: return .None
             case CONGRESS_PERSON: return .Person(Person(cstruct:w.person))
             case CONGRESS_LETTERCASE: return .Lettercase(Lettercase(cstruct:w.lettercase))
             default : fatalError( "insrcdata variant index overflow")
        }
    }

} // struct Congress

extension congress_iter_t : Sequence, IteratorProtocol {
        public typealias Element = Congress
        public mutating func next() -> Congress? {
            if let ptr = congress_next(&self) {
                return Congress(cstruct:ptr)
            }
            return nil
        }
}
enum  CongressObject : Hashable {
   case None
   case Person(Person)
   case Lettercase(Lettercase)
}



