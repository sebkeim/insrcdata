// generated by insrcdata version 0.1.0

#![allow(dead_code)]
#![allow(unused_variables)]
use std::ops::Deref;
#[derive(Clone, Copy)]
pub enum Clients {
    John = 0,
    Alix = 1,
    David = 2,
}
impl Deref for Clients {
    type Target =  Client;
    fn deref(&self) -> &'static Client {
        &client::TABLE[*self as usize]
    }
}
pub struct Client {
    name_ : &'static str,
}
impl Client {
    pub fn name(&self) -> &'static str { self.name_ }

    pub fn transactions(&self) -> TransactionIter {
        let cons = client::index_of(self) as u8;

        // bissect left
        let mut lo = 0;
        let mut hi = transaction::CLIENT_INDEX.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            if cons > transaction::TABLE[transaction::CLIENT_INDEX[mid] as usize].client_ {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        let start = lo;

        // bissect-right
        hi = transaction::CLIENT_INDEX.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            if cons < transaction::TABLE[transaction::CLIENT_INDEX[mid] as usize].client_  {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }

        transaction::IndexIter {
            indexes: Box::new(transaction::CLIENT_INDEX[start..lo].iter()),
        }
    }
}

mod client {


use std::mem;

pub struct IndexIter {
    pub indexes : Box<dyn Iterator<Item=&'static u8>>,
}

impl Iterator for IndexIter {
    type Item = & 'static super::Client;

    fn next(&mut self) -> Option<&'static super::Client> {
        let idx = self.indexes.next();
        match idx {
            Some(v) => Some(&TABLE[*v as usize]),
            None => None,
        }
    }
}

pub fn index_of(fic:&super::Client) -> usize {
    ((fic  as *const _ as usize) - (&TABLE[0]  as *const _ as usize)) / mem::size_of::<super::Client>()
}

const fn r(name:&'static str, ) -> super::Client {
    super::Client{name_:name, }
}

pub static TABLE : [ super::Client ; 3 ] = [
   {r("John", )},
   {r("Alix", )},
   {r("David", )},
];

} // mod client

pub use client::IndexIter as ClientIter;
#[derive(Clone, Copy)]
pub enum Products {
    Apple = 0,
    Banana = 1,
    Peach = 2,
    Cherry = 3,
}
impl Deref for Products {
    type Target =  Product;
    fn deref(&self) -> &'static Product {
        &product::TABLE[*self as usize]
    }
}
pub struct Product {
    name_ : &'static str,
}
impl Product {
    pub fn name(&self) -> &'static str { self.name_ }

    pub fn transactions(&self) -> TransactionIter {
        let cons = product::index_of(self) as u8;

        // bissect left
        let mut lo = 0;
        let mut hi = transaction::PRODUCT_INDEX.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            if cons > transaction::TABLE[transaction::PRODUCT_INDEX[mid] as usize].product_ {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        let start = lo;

        // bissect-right
        hi = transaction::PRODUCT_INDEX.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            if cons < transaction::TABLE[transaction::PRODUCT_INDEX[mid] as usize].product_  {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }

        transaction::IndexIter {
            indexes: Box::new(transaction::PRODUCT_INDEX[start..lo].iter()),
        }
    }
}

mod product {


use std::mem;

pub struct IndexIter {
    pub indexes : Box<dyn Iterator<Item=&'static u8>>,
}

impl Iterator for IndexIter {
    type Item = & 'static super::Product;

    fn next(&mut self) -> Option<&'static super::Product> {
        let idx = self.indexes.next();
        match idx {
            Some(v) => Some(&TABLE[*v as usize]),
            None => None,
        }
    }
}

pub fn index_of(fic:&super::Product) -> usize {
    ((fic  as *const _ as usize) - (&TABLE[0]  as *const _ as usize)) / mem::size_of::<super::Product>()
}

const fn r(name:&'static str, ) -> super::Product {
    super::Product{name_:name, }
}

pub static TABLE : [ super::Product ; 4 ] = [
   {r("Apple", )},
   {r("Banana", )},
   {r("Peach", )},
   {r("Cherry", )},
];

} // mod product

pub use product::IndexIter as ProductIter;
pub struct Transaction {
    client_ : u8,
    product_ : u8,
}
impl Transaction {
    pub fn client(&self) -> &'static Client {
        &client::TABLE[self.client_ as usize]
    }
    pub fn product(&self) -> &'static Product {
        &product::TABLE[self.product_ as usize]
    }
}

mod transaction {


use std::mem;

pub struct IndexIter {
    pub indexes : Box<dyn Iterator<Item=&'static u8>>,
}

impl Iterator for IndexIter {
    type Item = & 'static super::Transaction;

    fn next(&mut self) -> Option<&'static super::Transaction> {
        let idx = self.indexes.next();
        match idx {
            Some(v) => Some(&TABLE[*v as usize]),
            None => None,
        }
    }
}

pub fn index_of(fic:&super::Transaction) -> usize {
    ((fic  as *const _ as usize) - (&TABLE[0]  as *const _ as usize)) / mem::size_of::<super::Transaction>()
}

const fn r(client:u8, product:u8, ) -> super::Transaction {
    super::Transaction{client_:client, product_:product, }
}

pub static TABLE : [ super::Transaction ; 7 ] = [
   {r(0, 0, )},
   {r(0, 1, )},
   {r(1, 0, )},
   {r(1, 2, )},
   {r(2, 0, )},
   {r(2, 1, )},
   {r(2, 2, )},
];
pub static CLIENT_INDEX : [ u8 ; 7 ] = [
    0, 1, 2, 3, 4, 5, 6, 
];
pub static PRODUCT_INDEX : [ u8 ; 7 ] = [
    0, 2, 4, 1, 5, 3, 6, 
];

} // mod transaction

pub use transaction::IndexIter as TransactionIter;
