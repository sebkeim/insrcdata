// generated by insrcdata version 0.2.0

pub struct Leave {
    title_ : &'static str,
    chapter_code_ : &'static str,
    chapter_ : u8,
}
impl PartialEq<Self> for Leave {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}
impl Eq for Leave {}
impl std::hash::Hash for Leave {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        leave::index_of(self).hash(state);
    }
}

impl Leave {
    pub fn title(&self) -> &'static str { self.title_ }
    pub fn chapter_code(&self) -> &'static str { self.chapter_code_ }
    pub fn chapter(&self) -> &'static Chapter { &chapter::TABLE[self.chapter_ as usize]}
    /// Reference to the table containing all the values
    pub fn array() -> &'static [Leave; 9] { &leave::TABLE }
    /// Index of the current record in the table
    pub fn as_index(&self) -> usize { leave::index_of(self) }
}

mod leave {use super::*;

pub fn index_of(fic:&Leave) -> usize {
    ((fic  as *const _ as usize) - (&TABLE[0]  as *const _ as usize)) / std::mem::size_of::<Leave>()
}
pub struct IndexIter {
    pub indexes : Box<dyn Iterator<Item=&'static u8>>,
}

impl Iterator for IndexIter {
    type Item = & 'static Leave;

    fn next(&mut self) -> Option<&'static Leave> {
        let idx = self.indexes.next();
        match idx {
            Some(v) => Some(&TABLE[*v as usize]),
            None => None,
        }
    }
}


const fn r(title:&'static str, chapter_code:&'static str, chapter:u8, ) -> Leave {
    Leave{title_:title, chapter_code_:chapter_code, chapter_:chapter, }
}

pub static TABLE : [ Leave ; 9 ] = [
   {r("Terrier", "A1", 2, )},
   {r("Bulldog", "A1", 2, )},
   {r("Husky", "A1", 2, )},
   {r("Abyssinian ", "A2", 3, )},
   {r("Persian", "A2", 3, )},
   {r("Siamese", "A2", 3, )},
   {r("Begonia", "B1", 5, )},
   {r("Clematis", "B1", 5, )},
   {r("Oak", "B2", 6, )},
];
pub static CHAPTER_INDEX : [ u8 ; 9 ] = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 
];

} // mod leave

pub use leave::IndexIter as LeaveIter;
pub struct Chapter {
    title_ : &'static str,
    code_ : &'static str,
    parent_ : u8,
}
impl PartialEq<Self> for Chapter {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}
impl Eq for Chapter {}
impl std::hash::Hash for Chapter {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        chapter::index_of(self).hash(state);
    }
}

impl Chapter {
    pub fn title(&self) -> &'static str { self.title_ }
    pub fn code(&self) -> &'static str { self.code_ }
    pub fn code_range(start:& str, stop:& str) -> chapter::IndexIter {
        let mut lo = 0;
        let mut hi = chapter::CODE_INDEX.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            if start > chapter::TABLE[chapter::CODE_INDEX[mid] as usize].code_ {
                 lo = mid + 1;
            } else {
                 hi = mid;
            }
        }

        let begin = lo;
        hi = chapter::CODE_INDEX.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            if stop < chapter::TABLE[chapter::CODE_INDEX[mid] as usize].code_ {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        chapter::IndexIter {
            indexes: Box::new(chapter::CODE_INDEX[begin..lo].iter()),
        }
    }
    pub fn parent(&self) -> &'static Chapter { &chapter::TABLE[self.parent_ as usize]}
    pub fn leaves(&self) -> LeaveIter {
        let cons = chapter::index_of(self) as u8;

        // bissect left
        let mut lo = 0;
        let mut hi = leave::CHAPTER_INDEX.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            if cons > leave::TABLE[leave::CHAPTER_INDEX[mid] as usize].chapter_ {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        let start = lo;

        // bissect-right
        hi = leave::CHAPTER_INDEX.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            if cons < leave::TABLE[leave::CHAPTER_INDEX[mid] as usize].chapter_  {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }

        leave::IndexIter {
            indexes: Box::new(leave::CHAPTER_INDEX[start..lo].iter()),
        }
    }
    /// Reference to the table containing all the values
    pub fn array() -> &'static [Chapter; 7] { &chapter::TABLE }
    /// Index of the current record in the table
    pub fn as_index(&self) -> usize { chapter::index_of(self) }
}

mod chapter {use super::*;

pub fn index_of(fic:&Chapter) -> usize {
    ((fic  as *const _ as usize) - (&TABLE[0]  as *const _ as usize)) / std::mem::size_of::<Chapter>()
}
pub struct IndexIter {
    pub indexes : Box<dyn Iterator<Item=&'static u8>>,
}

impl Iterator for IndexIter {
    type Item = & 'static Chapter;

    fn next(&mut self) -> Option<&'static Chapter> {
        let idx = self.indexes.next();
        match idx {
            Some(v) => Some(&TABLE[*v as usize]),
            None => None,
        }
    }
}


const fn r(title:&'static str, code:&'static str, parent:u8, ) -> Chapter {
    Chapter{title_:title, code_:code, parent_:parent, }
}

pub static TABLE : [ Chapter ; 7 ] = [
   {r("root", "0", 0, )},
   {r("animals", "A", 0, )},
   {r("dogs", "A1", 1, )},
   {r("cats", "A2", 1, )},
   {r("plants", "B", 0, )},
   {r("flowers", "B1", 4, )},
   {r("trees", "B2", 4, )},
];
pub static CODE_INDEX : [ u8 ; 7 ] = [
    0, 1, 2, 3, 4, 5, 6, 
];
pub static PARENT_INDEX : [ u8 ; 7 ] = [
    0, 1, 4, 2, 3, 5, 6, 
];

} // mod chapter

pub use chapter::IndexIter as ChapterIter;
