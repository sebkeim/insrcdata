/// Countries and regions defined by UN M49 and  ISO 3166
// generated by insrcdata version 0.3.0
import Foundation

/// Continent of provenance
public struct Region : Hashable {
        var cstruct : UnsafePointer<region_t>
    
    /// English short name
    var name: String { String(cString:  region_name(cstruct)) }
    /// UN M49 code
    var code: UInt8 {  region_code(cstruct) }
    /// All the subregions belonging to the region
    var subregions:subregion_iter_t { region_subregions(cstruct) }

} // struct Region

extension region_iter_t : Sequence, IteratorProtocol {
        public typealias Element = Region
        public mutating func next() -> Region? {
            if let ptr = region_next(&self) {
                return Region(cstruct:ptr)
            }
            return nil
        }
}


/// Subcontinent as defined in UN M49
public struct Subregion : Hashable {
        var cstruct : UnsafePointer<subregion_t>
    
    /// English short name
    var name: String { String(cString:  subregion_name(cstruct)) }
    /// UN M49 code
    var code: UInt16 {  subregion_code(cstruct) }
    /// The region where the subregion is located
    var region : Region { Region(cstruct:subregion_region(cstruct)) }
    /// All the countries belonging to the subregions
    var countries:country_iter_t { subregion_countries(cstruct) }

} // struct Subregion

extension subregion_iter_t : Sequence, IteratorProtocol {
        public typealias Element = Subregion
        public mutating func next() -> Subregion? {
            if let ptr = subregion_next(&self) {
                return Subregion(cstruct:ptr)
            }
            return nil
        }
}


/// Country according to ISO/UN
public struct Country : Hashable {
        var cstruct : UnsafePointer<country_t>
    
    init(cstruct: UnsafePointer<country_t>){
        self.cstruct = cstruct
    }
    init(ref:countries_t){
        cstruct = country_from_countries(ref)
    }
    var countries: countries_t { country_countries(cstruct) }
    init(index:Int){
        cstruct = COUNTRY_TABLE_PTR()+index
    }
    /// English short name
    var name: String { String(cString:  country_name(cstruct)) }
    /// Two-letter country codes defined in ISO 3166-1
    var alpha2: String { String(cString:  country_alpha2(cstruct)) }
    /// Three-letter country codes defined in ISO 3166-1
    var alpha3: String { String(cString:  country_alpha3(cstruct)) }
    /// Search country by ISO 3166-1 three-letter code
    static func alpha3Range(start:String, stop:String) -> country_iter_t {
        country_alpha3_range(start.cString(using:.utf8), stop.cString(using:.utf8)) 
    }
    /// UN M49 code
    var code: UInt16 {  country_code(cstruct) }
    /// Search country by UN M49 code
    static func codeRange(start:UInt16, stop:UInt16) -> country_iter_t {
        country_code_range(start, stop) 
    }
    /// Subregion containing the country
    var subregion : Subregion? {
        var p = UnsafePointer<subregion_t>?(nil)
        if country_subregion(cstruct, &p) { return Subregion(cstruct:p!) } else { return nil }
    }

} // struct Country

extension country_iter_t : Sequence, IteratorProtocol {
        public typealias Element = Country
        public mutating func next() -> Country? {
            if let ptr = country_next(&self) {
                return Country(cstruct:ptr)
            }
            return nil
        }
}


