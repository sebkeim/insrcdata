// generated by insrcdata version 0.1.0

#![allow(dead_code)]
#![allow(unused_variables)]
use std::ops::Deref;
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum Adhocs {
    Filled = 0,
    Empty = 1,
}
impl Deref for Adhocs {
    type Target =  Adhoc;
    fn deref(&self) -> &'static Adhoc {
        &adhoc::TABLE[*self as usize]
    }
}
impl PartialEq<&Adhoc> for Adhocs {
    fn eq(&self, other: &&Adhoc) -> bool {
        std::ptr::eq(self as &Adhoc, *other)
    }
}

pub struct Adhoc {
    score_data_ : f32,
    count_data_ : u8,
}
impl PartialEq<Self> for Adhoc {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}
impl Eq for Adhoc {}
impl std::hash::Hash for Adhoc {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        adhoc::index_of(self).hash(state);
    }
}

impl Adhoc {
    pub fn score_data(&self) -> f32 { self.score_data_ }
    pub fn count_data(&self) -> u16 { self.count_data_ as u16 }
}

mod adhoc {

pub fn index_of(fic:&super::Adhoc) -> usize {
    ((fic  as *const _ as usize) - (&TABLE[0]  as *const _ as usize)) / std::mem::size_of::<super::Adhoc>()
}
const fn r(score_data:f32, count_data:u8, ) -> super::Adhoc {
    super::Adhoc{score_data_:score_data, count_data_:count_data, }
}

pub static TABLE : [ super::Adhoc ; 2 ] = [
   {r(100.0, 42, )},
   {r(-1.0, 0, )},
];

} // mod adhoc

pub struct Score {
    value_ : f32,
}
impl PartialEq<Self> for Score {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}
impl Eq for Score {}
impl std::hash::Hash for Score {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        score::index_of(self).hash(state);
    }
}

impl Score {
    pub fn value(&self) -> f32 { self.value_ }
}

mod score {

pub fn index_of(fic:&super::Score) -> usize {
    ((fic  as *const _ as usize) - (&TABLE[0]  as *const _ as usize)) / std::mem::size_of::<super::Score>()
}
const fn r(value:f32, ) -> super::Score {
    super::Score{value_:value, }
}

pub static TABLE : [ super::Score ; 1 ] = [
   {r(100.0, )},
];

} // mod score

pub struct Count {
    value_ : u8,
}
impl PartialEq<Self> for Count {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}
impl Eq for Count {}
impl std::hash::Hash for Count {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        count::index_of(self).hash(state);
    }
}

impl Count {
    pub fn value(&self) -> u16 { self.value_ as u16 }
}

mod count {

pub fn index_of(fic:&super::Count) -> usize {
    ((fic  as *const _ as usize) - (&TABLE[0]  as *const _ as usize)) / std::mem::size_of::<super::Count>()
}
const fn r(value:u8, ) -> super::Count {
    super::Count{value_:value, }
}

pub static TABLE : [ super::Count ; 1 ] = [
   {r(42, )},
];

} // mod count

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum Optjoins {
    Filled = 0,
    Empty = 1,
}
impl Deref for Optjoins {
    type Target =  Optjoin;
    fn deref(&self) -> &'static Optjoin {
        &optjoin::TABLE[*self as usize]
    }
}
impl PartialEq<&Optjoin> for Optjoins {
    fn eq(&self, other: &&Optjoin) -> bool {
        std::ptr::eq(self as &Optjoin, *other)
    }
}

pub struct Optjoin {
    score_join_ : u8,
    count_join_ : u8,
}
impl PartialEq<Self> for Optjoin {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}
impl Eq for Optjoin {}
impl std::hash::Hash for Optjoin {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        optjoin::index_of(self).hash(state);
    }
}

impl Optjoin {
    pub fn score_join(&self) -> Option<&'static Score> {
        let index = self.score_join_;
        if index==0 { None } else { Some(&score::TABLE[index as usize -1]) }
    }
    pub fn count_join(&self) -> Option<&'static Count> {
        let index = self.count_join_;
        if index==0 { None } else { Some(&count::TABLE[index as usize -1]) }
    }
}

mod optjoin {

pub fn index_of(fic:&super::Optjoin) -> usize {
    ((fic  as *const _ as usize) - (&TABLE[0]  as *const _ as usize)) / std::mem::size_of::<super::Optjoin>()
}
const fn r(score_join:u8, count_join:u8, ) -> super::Optjoin {
    super::Optjoin{score_join_:score_join, count_join_:count_join, }
}

pub static TABLE : [ super::Optjoin ; 2 ] = [
   {r(1, 1, )},
   {r(0, 0, )},
];

} // mod optjoin

