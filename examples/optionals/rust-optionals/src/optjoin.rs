// optional join strategy use optional join tables to store the values
// this the most robust approach but has some drawbacks :
//  - data size may become larger, except if many duplicate values
//  - range indexing become unreasonably complicated

use crate::{insrcdata, Optional};

// implement optional getter from methods generated by insrcdata
impl Optional for insrcdata::Optjoin {
    // getter for optional f32 value
    fn score(&self) -> Option<f32> {
        self.score_join().map(|v| v.value())
    }

    // getter for optional u16 value
    fn count(&self) -> Option<u16> {
        self.count_join().map(|v| v.value())
    }
}

//  optjoin strategy usage sample
pub fn sample() {
    println!("    Optional join strategy");
    <&insrcdata::Optjoin>::from(insrcdata::Optjoins::Filled).print("Filled");
    <&insrcdata::Optjoin>::from(insrcdata::Optjoins::Empty).print("Empty");
    println!();
}
