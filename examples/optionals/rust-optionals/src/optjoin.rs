use crate::insrcdata;

// optional join strategy use optional join tables to store the values
// this the most robust approach but has some drawbacks :
//  - data size may become larger, in the absence of duplicate values
//  - range indexing become unreasonably complicated

// implement optional getter from methods generated by insrcdata
pub trait Optjoin {
    // getter for optional f32 value
    fn score(&self) -> Option<f32> {
        self.score_join().map(|v| v.value())
    }

    // getter for optional u16 value
    fn count(&self) -> Option<u16> {
        self.count_join().map(|v| v.value())
    }

    #[doc(hidden)]
    // insrcdata methods
    fn score_join(&self) -> Option<&'static insrcdata::Score>;
    fn count_join(&self) -> Option<&'static insrcdata::Count>;
}

// print the content of a row
fn print(row: &dyn Optjoin, name: &str) {
    print!("{}", name);
    if let Some(score) = row.score() {
        print!(" score={}", score);
    }
    if let Some(count) = row.count() {
        print!(" count={}", count);
    }
    println!();
}

//  optjoin strategy usage sample
pub fn sample() {
    println!("    Optional join strategy");
    print(&*insrcdata::Optjoins::Filled, "Filled");
    print(&*insrcdata::Optjoins::Empty, "Empty");
    println!();
}
